	// The basic resource connector... not quite sure what it needs to do 27/02/2012.
	//  Fills in the gap conceptually.
	
	// These things will be nice when viewed through a web interface too.
	//  That is why the abstract resources are a useful system.
	
	// But there will be specific resource connectors that actually get used.
	//  A Resource_Connector is a Resource?
	//   Maybe. A resource (application resource) may be something that is a resource and available from the application code.
	//   These resources may be connectors to other / external resources.
	
	// The Resource_Connector is a Resource.
	//  Perhaps could make available Connected_Resource objects.
	//  There will be Application_Resource objects started first.
	
	
	
	// An Abstract (.NET terminology) Abstract class.
	//  Abstract in this development system means the representation of another system.
	//  Abstract code does not interact with existing systems directly.
	
	
	// Some resources will be local to start with.
	//  That means within the scope of the application.
	//  Need to initialize some resources immediately.
	//  Some just get created to start with, won't go through a loading process.
	
	// GPU computation as a resource could turn out to be very useful for doing things like creating image thumbnails.
	//  Not sure how easy it would be to get at the GUP image manipulation though, either through Node or on the client.
	
	// Resources like this will probably only apply on the server, though they would not definitely be excluded from the client.
	//  Perhaps some / many resources could only work on the server, but it may be useful for a client-side app to have these various resources, which
	//  would be a lot neater than global variables, and have their own system for getting information through those resources.
	
	// For the moment my focus will be on the server, but having mirroring on the client makes a lot of sense too.
	//  One early resource may be an index of other resources / expected resources
	// A resource connector could also do some scanning for a resource.
	// Could possibly describe an abstract da
	
	// Resource following a middleware pattern
	//  Takes an HTTP request, delivers a response.
	//  Request -> Response is a pattern is some middleware like JSGI. Mine will be more complicated, probably won't do as many requests / responses per second either.
	// The resource exists between requests. Some will provide caching, could have a caching resource, some resources could do caching themselves.
	//  It's not just calling a function, the resources will need to be configured.
	// Some resource references will imply that the resource should be set up in a certain way.
	
	// Server will create a few resources to start with.
	//  Some will initialize immediately, things that don't need to load data using callbacks.
	// Resources will have their functions use callbacks as a matter of course so that they can work asyncronously when needed, or immediately call the callback when able.
	//  This may also be useful for changing the internals of the resources to use other processing mechanisms / engines perhaps.
	
	// The resource may have a function like get_data(callback),
	//  maybe get_data(params, callback)
	// This will mean that the resources get the data that they are supposed to get.
	
	// resource created as an object in the app
	//  (local resource)
	// remote resources could be stored in a resource index (which is a local resource)
	//  The resource index could maybe told to look for a resource.
	//   What is expected to be at any resource location?
	//   The resource connector could handle this interaction.
	
	// Collection of resources:
	//  The collection will help with events for numerous resources.
	
	// The application will have and use various resources.
	// They can be considered fairly self-contained units in their own rights.
	//  Some resources, such as a website resource, would require access to some resources in order to do things.
	//   They could be provided with resource connections or resources.
	
	// Website resource:
	//  Requires a web-db resource.
	//   Will be able to use a web-db-postgres resource? Or a connector resource?
	
	// Something that connects the website resource to the database?
	
	//  These resources as apps in their own right - may be best to make the website server resource after a few other resources have been made first.
	//  Apps in their own right....
	//  The web server connects to a web-db-resource-provider.
	//   This may then get the resource through postgres.
	
	// There will be quite a few levels of abstraction and decision making.
	//  The resources make for abstract wrappers to functionality, particularly functionality that exposes data, and also functionality that processes data.
	//  Some resource providers will have a variety of places where they could get that resource from.
	//   The web-db-provider may need to initialize a web-db-postgres provider to get the work done.
	
	// An abstract postgres database could be held as a local resource.
	//  Or an abstract database, and an indicated preference to use Postgres.
	
	// To begin with, will want to tell it to use Postgres.
	//  Currently the database gets generated as abstract-postgres.
	//   In the future, will generate abstract-db, and then transform that to the Postgres variety.
	// web-db-postgres is likely to be useful, but packaged as a resource.
	
	// Some resources will need references to object instances to work. Those objects may not quite be ready either.
	//  It's going to wait until the necessary objects are ready.
	
	// Need to be quite flexible for the moment in what resources actually do.
	// I think starting the web-db-postgres resource would be a good start.
	//  Use a Resource class to load and manage that resource.
	// Define a resource - tell the application that there is a particular db configuration.
	//  Find a resource that can be transformed into / used as the defined resource.
	//  Use the resource connector to set up the found resource as the defined (abstract) resource.
	
	// Resources existing in abstract (database design, postgres web db abstraction) and existing on a separate computer system, where it will be usable.
	//  Will want to use abstract resources to define and describe various resources.
	//  The resource classes themselves may represent various resources
	//  Resource connectors may be used to connect to them, and will be resources in their own right.
	
	// Possibly will have a resource index.
	// Possibly will use the collection's indexing capabilities.
	
	// Some resources to begin with may not contain very much information.
	//  They may show where further information can be obtained.
	
	// Some resources could make further resources available. An index would work in a similar way to a resource finder.
	//  Once the resource finder has found resources (external resources), it will raise an event/callback, and those resources will be available to the app as external resources
	//   (I think external resource may be a type of resource, it will be used by the resource connector).
	//   Maybe the resource connector will provide a local resource? Connected resource?
	//  Eg correctly named Postgres database is found. A remote resource object is created representing it.
	//  The Postgres resource connector connects to it, and makes a postgres-web-db or web-db resource.
	// Different levels of validation that an external resource contains what it should contain.
	//  Potentially instructions for changing it.
	
	// Not sure quite how much code it will take to put things in as resources.
	//  Maybe dbi-postgres is nice as it is for the moment. It follows the Postgres spec where possible, and is fairly clearly defined.
	//  May be best to create a new / some new Postgres DB resource classes.
	//   Use a fairly generic resource description class to describe it
	//   Use a postgres-connector resource to connect to it
	//    That supplies a postgres-resource when it has connected (like how an index has resources nested within it)
	//  Use a web-db-postgres resource - that resource may use (consume) the postgres-resource that has already been provided, and provide a web-db-postgres resource.
	
	// Not sure at the moment about recoding lots of things as resources.
	//  It may not really be a problem, but may be best to get some of the resource system made to get a better idea of the API.
	
	// Some resources won't require input.
	// Others will function through providing responses to input.
	//  Want there to be very simple resources that already have their data (but possibly could have data added)
	// Some resources will be created through a process, may be an automatic process when the resources are starting up.
	// Could have a resource loader to begin with?
	// Or the resource connector saying it needs access to a resource.
	
	// Need a resource pool. This way the resources can access each other when needed.
	//  One simple way of doing this is to give each resource its own string key.
	//  Resources will have some information indicating their types.
	
	// Want resource pool to have its own indexing implemetation for the moment.
	//  Don't think resource pool should be a resource. It should be an application level object.
	//   Though possibly a resource-pool-publisher could publish it as a resource.
	
	// Create resource in local app, publish it
	// Create reference to remote resource in local app, connect to it with a resouce-connector, consume it
	
	// Resources will wind up being quite flexible, but I think they will wind up having a very restricted API.
	//  I think that is the challenge here. Don't want to make assumptions about what or where a resource is. Merely that it needs to be able to be made locally available.
	
	// Possibly refer to WSDL. Being able to store a resource's WSDL could be very beneficial for consuming it.
	//  Automatic connection to online services through WSDL and similar would be very useful.
	
	// Resource_Connector:
	//  The location of the resource to connect to
	//  Connection status (events, variables)
	//  A prototype of what should be found at that location / instructions to change/upgrade it from previous versions
	//  Provides the resource itself (makes it available to the resource pool)
	// Resource_Connector is a resource itself?
	//  Or a piece of code machinary to use these resources?
	// Having Resource_Connector objects within the Resource framework could make sense. This way the system could see which resources it is possible to connect to.
	//  Quite a few things will need to work together in synergy. A fair few pieces of functionality will be put in place, some of them may seem to be mostly wrapping.
	//  Some abstraction patterns will emerge from the resources code.
	// Will be able to have a resource represent a file served in a certain way.
	// I think the server may be a resource running within the application.
	
	// Resources may be more like ALOs, Application Level Objects.
	//  ALRs?
	// When resources require other resources, they can refer to the pool to get them, or possibly get them loaded.
	//  Resources may be provided with the most appropriate resources.
	//  Web db resource may be provided with the db resource rather than having to connect to it itself.
	//  Web db resource could be a resource connector itself? Resource transformer?
	
	// Basically in this system, everything, or almost everything is a resource.
	//  They could just be normal objects so long as they follow the resource API.
	
	// That resource API is something that could do with a bit of work.
	//  connect (optional)
	//  process (some data)
	//   maybe get?
	//   get would be better for just getting existing data without processing.
	
	//  resource.get(params)
	//  resource.status() gets the status of the resource.
	//  resource.set(params) - setting values within a resource
	//  resource.call(function_name, params) - not called that
	//   resource.use
	//  resource.config(config)
	//  resource.config() gets the config
	//   some resources won't have much or any configuration
	//  resource.api gets the api. List of functions that the resource exposes.
	//   some of those functions may conform to other APIs. they could be specified. I think getting the function signature
	//   will do a lot to distinguish between function, and allow them to be used by the application that knows what to do with them.
	
	//  resource.start()
	//  resource.stop()
	//  resource.restart()
	//  resource.config_restart()
	//   and the resource handles various events, it's a data object.
	
	// The resource could be running in the process.
	//  With the network sharing being a different part, or a wrapper.
	
	// Resources may do streaming. There could be a streaming API.
	
	// Creating / ensuring existence of a resource:
	//  Possibly will create local / external resources like postgres servers. (actually installing them)
	
	// I think a good early resource would be a service finder.
	//  It may do a port scan.
	
	// It could check ports for specific services.
	//  This will likely make available abstract resources for the resources they find.
	
	// Resource connector: Consumes abstract resource, provides connected resource (resource that works like its local)
	
	// Arranging things as resources will take some time... I think it will be worth it when these resources are working together.
	//  It provides an easy interface to see what's available and usable... and then there is the programmatic interface to use it.
	
	// Connecting to, and doing CRUD for a Microsoft SQL Server is likely to prove to be one of the most commerically important thing.
	//  Would be very useful for importing data from legacy systems, amongst other things.
	
	// SQL Server DB -> Abstract DB -> Postgres DB
	
	// We could see what ports are in use...
	
	// Possibly could connect more directly to the local Postgres port?
	//  May do longer port scan that reveals more information but does not complete for a little while.
	
	// The resource finder should maybe verify a resource is at a location.
	//  Should we do specific checks for specific services (on specific ports?)
	
	// Wrapping existing things as resources may prove useful.
	
	// May be worth creating a few things with the standardised API.
	//  It will make connecting to these things, and validating connection info easier.
	
	// Treating the web-db as a resource may be helpful.
	//  Its resource-connector may provide functions that carry out its methods.
	
	// This resource system will be relatively lightweight. Relatively simple API.
	// Could make a hello world resource?
	//  Could be a resource that wraps a string object.
	//   Could have get, set, and various string functions
	// There may be quite a few / variety of resources. Perhaps some resources will have various capabilities such as enabling read only mode.
	//  Some resources could be designated as read only for some users, while other users would have write access to it.
	
	// This resource adds another layer which would be unnecessary in some situations.
	//  It will be very useful for having a working admin interface.
	
	// Probably worth expressing the DB system as a resource.
	//  Publishing a resource... would be tricky with the various security options but it can be done.
	
	// Discover Postgres resource
	// Make Postgres resource available as local
	// Use the Postgres resource to create a postgres-web-db resource (perhaps call this a Virtual Resource?)
	//  The postgres db or server resource is used 
	
	// When the program has access to a postgres-web-db resource (which will have the same interface as other web db resources), it will be able to use a JavaScript interface for interacting
	//  with the web database.
	
	// (resource.get_description) - not sure what this will be called.
	//  resource.api
	//  Will return something describing its api?
	// resource.api - gets the api for the resource
	//   we already know it's using the resource API, but each resource can have its own API describing the functions it has.
	//   May just say that it provides various pieces of data
	//   May say it exposes various pieces of functionality (can have text descriptions) using various specified functions.
	
	// An index / directory of resources.
	//  Resources may need to have names for this to work well, but they could be automatically generated if necessary.
	//  Local Postgres server could be one name
	//   [db_name]postgres_database could be another.
	
	// The resources could be indexed by their resource type and location
	//  That way the local database could be identified through parameters specifying what it is.
	
	// I think after quite a bit of work with this there will be quite a simple and convenient interface.
	//  Will make it very easy to use the local postgres server if there is one.
	//   There will likely be a further wrapper layer to act as a shortcut to the use(fn_name, params) methodology.
	//    Use could take an array of functions an call them sequentially.
	
	// Wrapping a generic SOAP resource
	//  Wrapping a specific SOAP resource into an object that has the various functions available as JavaScript functions.
	
	
	
	// Expected resources... say the system expeces the postgres database at a certain place.
	//  SQLite may be best for the most basic service config options, but will use Postgres for now.
	
	// Set up a resource
	// Use a resource
	// Get a resource to describe itself
	//  As an abstract resource I suppose.
	// Publish a resource
	//  Not so sure how this is an action of a resource. Maybe there will be resource_publishers?
	//  Or each resource can be talked to?
	//  Eg a database resource: other machines may be able to access this resource by publishing it.
	//  It is more that to begin with different systems in the network are available on various other systems.
	
	// A resource directory would make a fairly good resource.
	//  It may find resources through a callback.
	
	
	
	// I think this means that there is going to be quite a variety, but not an infinite variety of things that a resource can do.
	
	// Also need to work out which classes will be used to implement running resources, which will be used to describe them.
	//  This system is getting a bit complex but it will all work well together.
	
	// In many cases the resource itself is available through a connector, and the connector is a resource.
	// We don't really have a Postgres resource set up locally, its a resource connector.
	//  I suppose the resource itself is available locally, but probably best not to call the connection object (or an object provided by it) the resource itself,
	//  because that resource really exists remotely to the application.
	
	// The local resources:
	//  Resource indexes / directories
	//   Say what is available, where (local and remote locations)
	//  Resource connectors
	//   connect to remote resources
	//  (Connected resources) Resources made available locally as if they are local resources.
	//    Perhaps that does make sense. A resource connector produces a Connected_Resource object.
	
	// A Postgres database resource will wind up exposed as a local resource.
	//  Should be a general purpose function for a resource, where it processes input.
	//   Maybe only some of them?
	//  Different functions exposed?
	//   The main function?
	//  For the postgres db, get would be to get the query result.
	//  However there could be other things in the interface like execute a function, returning a single value.
	
	// The resources in a real system may be quite varied:
	//  Example: Other business app is using SQL Server.
	//  Use the SQL Server resource
	//  Make a resource connector to connect to that particulat resource with the interface exposes through that system.
	//   May have a fairly easy way of getting / setting data from that resource because of the framework.
	
	// I think it requires quite a lot of programming, of the right design.
	// Hopefully the resources framework is going to make it easier to get an app with various components running.
	//  The components won't have to be located on the same system by making resources available over a network.
	//  This may be useful for application level resources that are not published externally, they will be adressable over a LAN.
	
	// This poses a significant extra abstraction for the moment.
	
	// Makes a lot of sense for identifying where things are.
	
	// A resource pool? Every resource in the pool has access to every other resource?
	//  That could work well on the client too, because there could be data resources available separate to the GUI controls.
	//   This would be or be like an MVC pattern.
	
	// The resource is the model...?
	
	// Can't really respond to a change in a DB like in MVC?
	//  Triggers?
	
	// To begin with, will want to define various things as resources.
	
	// The database
	//  As a web-db
	//   Then within this, there could be other resources.
	
	// Using the web db resource
	// Exposing web db as a resource
	
	// May want to write resource adapters to turn various general objects / classes into these resources.
	
	// Could make some fairly simple resources to start with.
	//  Could make immutable resources that don't have set.
	
	// Could make a few resources.
	//  Possibly have them talk to each other within the app.
	
	//  Possibly have them talk between apps.
	
	// Resources available within the application:
	//  May have been published from elsewhere.
	//  Perhaps not published. Could say 'provided' for resources made available within the application process.
	//  Postgres db resource could be provided
	//   A web-postgres-db resource could adapt it and provide it for internal use.
	//   It would then be a resource publisher that would publish it to the wider network.
	//    I don't think there will need to be a web-postgres-db resource publisher, or particularly specialized publishers. The publisher will be a bridge between a published API and the resource's
	//    API. It should generally make the resource's functions easy to call.
	
	// Adapt object into resource
	// Adapt class into resource class
	//  May work on the network sharing of the resources first.
	//  Calling a postgres DB or Tokyo Cabinet DB on a particular node would be very useful indeed.
	// A simple API could be exposed for many things, making the functionality available accross a network.
	
	// This resource system will be invisible at times - should be easy to make it work well.
	//  It may choose different communication options, such as BSON. Could have backwards compability on interfaces, and the components could say what version they are.
	
	// API name
	// API version.
	
	// Could have more namespaceing things so that some things get put into / released as a certain namespace.
	
	// Such as metabench.network_printer.
	
	// Something here to wrap network functionality as a resource?
	
	// Also, system to make the resources on a particular node / instance visible to each other.
	
	// Class that 'hosts'? an object as a resource.
	
	// Wrap the object as a resource
	
	// Serve / publish the resource.
	
	// When it is a resource on the local system, would need to publish it for it to be more widely available.
	
	// There is a general purpose resource publisher.
	//  Others could be more specialized like output a video stream with RTSP or other protocol.
	
	// This resources model would be an abstraction for quite a few things...
	//  Different things could be added into and removed from the mix without having to re-arrange code.
	
	// Each node process would have a list of its published resources.
	//  Possibly have unlisted resources too.
	//   Resources will generally show in the resource list.
	
	// Would be very nice to be able to define particular resource APIs.
	//  KVS.
	//  Doc DB
	//  NoSql_General_Min
	//  Mongo
	
	// Web resources - resources within other web sites.
	//  The resources themselves could be, or could be within other websites.
	
	// Then there would be interfaces between somewhat generalized resources.
	//  Like 
	
	// Resources shared / published on a port?
	//  Port and a path?
	
	// Could have things set up so that multiple ports are served... though this will maybe happen with several node processes as well.
	
	// Resources (such as websites) could be accessed through a path within them.
	//  Some resources, such as remote data, won't work in quite the same way, or the means of defining the path would need to be defined too.
	
	// A resource would be very general purpose then...?
	//  Publish a resource on a port, with a given path.
	//  Website resources will have more specialized publishing
	//  There may be object / RESTful resources too.
	
	// Resources containing other resources may be possible.
	
	// Should be able to consume XML web services as resources without too much difficulty.
	
	// Finding, providing and consuming the DB resource.
	//  That is one of the main challenges for the database driven website at the moment.
	
	// Resources will be available as:
	//  abstract descriptions
	//  connected resources
	
	// Can possibly 'tap' resources? A resource could possibly be a printer with a queue.
	//  Information that is used to render a page could be described using this system too, as could the rendering of that page.
	
	// Within the client app it will be less of an issue, but could help tie things in with a user interface and be useful in MVC patterns.
	//  Connecting to various networked resources could still be done, but possibly using a proxy, iframe or other method.
	//   cross-domain.
	//  May get resource metadata from metabench and use that to access various other pieces of data as resources.
	
	// Resource description / resource metadata.
	
	// Could have a resource that indicates that a URL has links to the UN's published data. Then other pieces of metadata inside that resource about the other data.
	//  The data linked to by the resource could then be analysed and used as a resource.
	
	// Can have stages of obtaining more information about a resource.
	//  Discovery phase.
	//   This is like someone's senses.
	
	// Abstract resource... say what port it is on.
	
	// Resources could refer to real-world objects too.
	
	// Resource is quite an abstract thing in itself.
	
	// A resource object in the program will be a resource that is usable with the program and can be published as a resource.
	
	// Otherwise, would have Publisher classes, these publish an object (maybe a resource) as a resource.
	
	// For example, could define various resources within a website (eg music files)
	//  Could keep the resources the same while changing the publishing system.
	//  Would then be able to have interchangable resource publishing systems. The various components could be interchanged as new, improved ones are made.
	
	// Also, the resources system will be useful for having things available (and indexed) within an app.
	//  Need to sort out resource discovery and publishing for postgres db resources.
	//  Resource adapter adapting the postgres db resource into a postgres web db resource.
	
	// The postgres db will only be connected to as a resource once it is discovered.
	
	// Could possibly be in the index as an abstract resource, and then it checks to see if it is there.
	
	// Initially doing some kind of port scan on application initialization seems like a good move.
	//  May possibly see what resources are available on the LAN.
	
	// Also, may look across various computers for specialized resources using specific protocols.
	
	// Some ports may appear closed anyway... may need to connect to them with a specific means.
	
	// Also, with the application running... it would be nice for the application to provide information about itself as a network resource.
	
	// Really getting on for a lot of text here. Will probably be a lot of code in total, but the core of it will be very small.
	
	// It may be worth making the system, and then finding out which things are most core.
	
	// Each node process could be a resource that's available to other node processes. Could call a function on it without too much difficulty.
	
	// Want the authentication system to be pluggable too. Won't always be using the postgres web db.
	
	// Need to get more done on the postgres web db system to hold the authentication data before doing so much more on making these resources available.
	
	// Some resources could be published as XML web services.
	// Others published as websites with CMS and admin interface.
	
	// The specific things to get this website running seem like the most worthwhile part of the resource system to make.
	
	// Resource index seems like one of the most important things.
	//  Will be used by the application process so that it knows what resources are available.
	
	// Could start with some expected resources, like a local postgres server.
	//  It could then use resources as they become available, adapting them.
	//  Very soon after starting, the postgres web db would become available. Configuration steps are done as needed.
	
	// Then when the web db is available, the website can connect to it.
	
	// Need to be very specific about which resources get used... local postgres for example.
	// This will need to be set clearly at an early stage, eg 'web_db': 'local postgres'.
	//  Could have different string shorthands, like 'hakus.org:6392 postgres'
	
	// These will be connected to by the app without too much difficulty.
	//  Or at least the hard work takes place behind the scenes.
	
	// Not sure about packaging code as resources.
	//  It may make sense as a way to modularize things. Could be a system for loading code when needed.
	//  This abstract framework will be enough for many things to work.
	//  For the moment should only wrap some things as resources.
	//   It is quite a general term, and exactly where it will be most useful is yet to be determined.
	//   It's likely that it will wind up baked into the whole system.
	
	// Getting the computer's network address can be useful for starting the server?
	
	// The server is a resource? Perhaps - may work programatically. May be able to modify the server remotely (with the right credentials)
	//  Or the website is a resource that is within / hosted by the server.
	
	// The server is a resource, so it the website.
	//  The server will have an api to say what is available.
	//   Could use a normal, or a behind-the-scenes resource communication system.
	//  The server publishes the website resource.
	//   Therefore its config address or its resource description can't be the base URL.
	//    Or it is the base URL, but it receives a specific request, like method 'GET' body 'resource description'. Seems like a good use of the body in a get request.
	
	// 'GET' body 'resource description' - gets the website's description
	// 'GET' body 'server resource description' - gets the server's resource description. Because the server is serving the website resource on its URL, the prefix 
	//  'server' denotes that it is the server the command is being applied to.
	
	// May be worth setting up these basic classes and behaviours.
	//  It may not be that long until the thing is programmed now that I have had a really good think about it.
	//   Needs to be abstract and enterprisey. The resources system will help with distributed applications.
	//   With this, it may be possible to provision lots of servers (could use Amazon, and have the system set itself up on them).
	//    Deployment systems can be put in, so that a node will be able to get defined and deployed. There will be monitoring and automatic adjustment capabilities.
	//    
	
	// I think the server as a resource and the website as a resource are very important things to start with.
	// The resource pool is another very important thing, it will hold it together. This may become called an 'index' but it may do more than that.
	//  When some resources get loaded / made available, other resources will make use of them.
	
	// For example, a resource pool could be initialized as follows:
	
	// 'web_db': 'local_postgres',
	// 'website': 'website, uses web_db as web_db'.
	
	// Not sure exactly, some resources will effectively have parameters. They require resources of particular types.
	//  They may require a web-db resource.
	//  Want it so that even if there a few web-db resources in the pool, it knows to use the right one.
	//  The default configuration? There could be a variety of simple configuration options available.
	//   A simple deployment would be using Postgres on the local machine.
	//   A more complex deployment could give a network location for the web-db - this web db would be a resource.
	
	// Serving a non-website resouce from a server...
	//  Is there that much need to have a 'server', if all resources/many of them can act as servers anyway?
	
	// Everything's a server??? 
	//  These various resources that get shared will need to have network server capability, and they will talk to each other using network protocols.
	
	// The server may be the object that publishes the resource.
	//  There will possibly be multiple ways to do things.
	// Have a website run outside of a server, or use a server resource which could provide extra flexibility.
	//  The website's content, in the abstract, will be rendered and modified in various ways.
	
	// Having a separate website (server) object within the main server object could help with rapid interchangability.
	//  There will be quite a lot of levels of flexibility on this, making a quite complicated system, but the system as a whole will be easy to use.
	
	// By structuring this right, no one part will need to be too complex, though they may have some complexity encapsulated within them further.
	//  These processes will be running on lots of machines at once, and will need to be in co-ordination.
	//   Changing the structure of the network, while it is running, will be one of the tasks.
	// The server resource:
	//  Represents what the process will reveal about itself, things will be monitorable and configurable through this.
	//   Like how much CPU the process is taking.
	//  Then the website (and could be other services on different ports)
	//   The website will use resources etc.
	//    Possibly the admin interface to the website will be through the server's admin interface.
	//     There may be a central controller for admin on some deployments, and these will need to get the changes replicated across the network.
	//  This code will deal with both the running and the deployment of services.
	//   A scaling manager seems like an important part of it.
	
	// Pieces of data, such as social networking profiles, could be regarded as 'resources'.
	//  The access of them on one software level would be disconnected from their physical storage.
	
	// In a single node, the resource pool could include other resources from the application system, but dealt with through an abstraction.
	//  It may not be one single network address, but be sharded. May be a number of nodes that are of idential config, and they get used randomly / randomly with weighting.
	//  Building this into the system will be helpful for making an enterprise app, also useful in robotics with controlling multiple things at once.
	
	// For the moment, getting the server resource running, with a resource pool, would be nice.
	//  The resource pool would (initially) just be for use within the application.
	//   Resources in that pool could be published.
	
	// Resources with their default publishing systems... publishing systems will be interchangable, but there will be a standard website publishing system for the moment.
	//  Maybe not just one... websites could be arranged in different ways. I'll make it abstract enough so that the particular system I'm using right now will be swappable for another one.
	
	// Server... it would definitely help to know the server's network address at the beginning. This is something it looks like I'll have to code for Windows.
	//  
		
	
	//    If the request does not have a body, it sends the request straight onto its root/only published item.
	
	// The server publishes a resource (the website) on a port.
	//  It will have an admin interface (could change the website being served to a different one)
	//  The website itself will have its own admin interface.
	//   If the whole website is served from the DB and based on components, the whole thing will be changable using the RESTful interface.
	//   That will provide a good interface for client-side tools to manage the content of the website.
	//  The website would be available at the root URL, so administration commands would need to be clear if they are referring to the website or the server.
	//   Perhaps all the commands would be directed to the server anyway. 
	
	
	
	// Can I have the MetaBench website done within one week using this?
	//  Probably not.
	//  There is more to do on the CRUD / persistance. Also authentication.
	//   Will be very nice when the website is up and running. I'd be able to provide somewhere for customers to upload what they want.
	//   Would be good to have a nice, useful interface that customers can access. Perhaps view time etc. Maybe I'd host some files for work on them and share them with
	//    other team members. Give each of them a username / password. Could possibly send them a link by email that logs them in, saves a cookie on that machine.
	
	// MultiPortServer resource?
	//  Can serve on multiple ports at once.
	
	// PortServer, serves on a single port.
	
	// The MultiPortServer 
	
	
	// The website is a resource. Likely to contain other resources.
	//  A structure, menus, the information itself within the structure.
	//   Diagrams and other embedded objects could possibly be referred to by using resources.
	//    They could be image files that have been published. They could be available in different resolutions or as vector graphics.
	//     So the reference is to an image within the system, rather than necessarily just an image file.
	//     Could be similar in referring to an audio track rather than just a sound file (though the sound file may contain metadata).
	
	// The server admin system could help with administering the resource pool.
	
	// But maybe the resource pool should be a resource in its own right?
	
	
	
	
	
	// starting the resource pool.
	//  callbacks for the resource pool / events.
	//  events may get wired up through Data_Object.
	
	// Then when the app has loaded, the resource pool is going to run the startup sequence.
	//  This is where the resources that requires a startup sequence get going
	
	// Start all of the resources that are set to automatically start.
	//  Some of these will be reliant on other resources.
	//  Eg the web-db-postgres resource relies on there being a running postgres-db resource running.
	//   Like in Windows Services, it will need to start a number of them for some particular ones.
	//   Different to Windows Services, there could be more than one postgres service, for example. There will possibly be multiple running Postgres services, and the local
	//    one, or the most local one is the one that gets connected to.
	
	// Assume local for some things?
	//  A whole system of starting the local services / resources?
	
	// Probably can't connect to and verify various resources without the username and password anyway.
	
	// Connecting to the local Postgres database...
	//  should be told to do so, or that there is such a database.
		
	// There will be different resources that start in these resource pools.
	//  Perhaps resource connectors will be resources in the pools to begin with.
	//   They would make more resources available to the pool.
	//    Resource versions may be an issue at some times.
	
	// Resources need to have an interface (or more than one interface).
	//  There will be various providers and consumers that do particular things, and require various things.
	//  It is a bit like implementing a class system on top of JavaScript.
	
	// The system gets quite complicated because it deals with the various interfaces of resources.
	//  Perhaps Resource will have a 'resource' interface.
	
	// The api will say what the object does really.
	//  There will be ways of mixing API based objects 
	
	// web-db api
	// Though the APIs will need some flexibility too.
	//  May have different API versions too. Don't want the APIs to be changing too much, but they could potentially be changing.
	//   Unsure about making it so that the resource can use different layers of the API for backwards compatability.
	//   Could make backwards compatability API adapters potentially.
	
	// A resource will require various other resources.
	//  When used, the resource will have a local_name.
	//  Will also have a name within the resource pool.
	
	// This will be a way to ensure the system has all the data and other components it needs, while providing the means for those components to be changed
	//  and could be using different means to actually store the data, while still providing the same API to the components in the app that are using it.
	//  This will allow refinement on indexing systems, where a simpler indexing system could be put in place (that uses more space) and then more compressed indexing
	//   and combined storage engines could be put in place as they get developed. Some such systems will be relatively simple interfaces to other database systems.
	
	// Definitely do want to have some in-process node storage components. These would be very cool when operated over a network.
	//  This will be a bit like how parameters are given in strongly typed languages.
	//  The parameter types are equivalent to types in such languages.
	
	// I will make the website resource, and make the web-db resource.
	//  The web-db resource will use/provide the web-db api and various implementations of it will be using other resources.
	//  It's possible it will be split further into authentication providers.
	
	// Splitting up some of the services that run the website makes some sense. Authentication, authorization.
	
	// Authorization mechanism takes authenticated user ID, then it looks at the particular resource to see who it gets shared with.
	//  That could be stored in the resource metadata.
	
	// Objects will be able to expose more than one API at once. There could be something like different API levels, with there being some levels (different to versions)
	//  that expose some more functionality.
	
	// It would be worth having a relatively simple object data API.
	//  May be worth having various existing code systems, such as both mongo and mongoose, available as these resources.
	
	// Can do a lot just with the authentication system and the document system.
	//  Document metadata, the document itself. Getting these working nicely will be very good, and different document storage mechanisms can be made.
	//  
	
	
	// Will make an app_website resource - this will be a specific configuration of various resources.
	//  Could make some resource packs perhaps?
	//   These would be resources that perform some particular task, but they could do so on top of an already established interface, so that pieces can be changed as needed.
	//   Swapping various components should be a fairly easy task.
	//   Want operations like that done through a nice GUI.
	
	// For the moment, want the web authentication system.
	//  Will also say what roles a user has.
	
	// Then username and roles' names / user id / roles' ids will be used to check if the user has access to the resource.
	//  The whole system should be possible to make in Mongo without too much difficulty.
	//  Then it will be a useful basis for further things.
	//   Should be easy to talk to mongo when working in a distributed application.
	
	// This credentials and document resource system will be very useful for lots of things. Can integrate document editing with it - though a document editor client
	//  app would likely be a resource in itself. These document editors could have / use a very simple API for plugging into the framework. Exactly how the document
	//  gets editied would be a different choice, but I'll have a fair few that are closely integrated with the jsgui server and client libraries.
	
	// Do want to get the ASP.NET-like components working fairly soon.
	//  They will be good for providing a consistant platform using patterns that people are familiar with.
	
	// Web db resource
	//  Needs the authentication resource
	//   Authentication can use its own database resource
	//  Needs the object database resource
	
	// Connecting the node process to an authentication provider.
	//  This should be a possibility too. Authentication provided over a network is an option. I do like the idea of the possibility of separate logins, but
	//  I also like the simplicity of just using one login system for administering the nodes and for the whole system.
	
	// Let's make this authentication system using Mongo.
	//  Should be possible to connect to it with some initial credentials.
	
	// Also am still interested in storing local node and process information in an sqlite database.
	//  That would perhaps need work on an ORM layer, not so sure about doing that right now.
	
	// Going straight to a Mongo database may be best.
	//  I think the various other measures would be very useful too.
	//  Perhaps will look for the mongo database from information stored in a local system.
	
	// Data connector resources
	//  Connect to the data source
	// Data API resources
	//  Present an API that is suitable for a task
	// There will be data APIs on top of the original data sources.
	//  They will be simplified to some extent from the API provided by the database platform
	
	// I think taking some config options just as a string or file makes a lot of sense too.
	//  Don't really need to use sqlite to store a bunch of settings like this.
	
	
	// Local file resource
	//  File API
	
	// Various resources and APIs will be exposed across the network.
	//  I think a fairly simple Mongo resource would be good.
	//  It may be possible to have a Mongo resource that implements a simple API as well as having mongo specific extensions.
	// I think platform based extensions for resources makes sense.
	
	// I think get the local server information resource running.
	
	// Also the local mongo resource.
	
	// I think I'll make the mongo and postgres db resources.
	//  They will have APIs that follow the database.
	// Postgres may require an ORM layer to be that easy to use by the website or a web-db resource.
	//  The Web_DB resource will bring together different resources of lower level APIs, such as an Object_DB
	//  Relational_Web_DB
	//  Object_Web_DB
	//   Each of them use a wrapper for the particular web database or relational database implementation.
	
	// Resources will have a 'requires' system. requirements?
	//  Before starting, it will check that the requirements are met.
	//  If they are not, it produces an object saying which requirements were not met, and maybe how.
	
	// The resource won't (necessarily) publish over a web interface.
	
	// There will be resource publishers for that.
	
	
	// The Local_Server_Info is a Resource, but it does not (yet) have a publisher.
	//  There could be a general resource publisher.
	//   Allows various actions to be taken with RDL triples?
	
	// At the beginning the Server Admin resource needs to be published...
	//  That gives access to the resource pool. Maybe resource pool should be a resource.
	//   Perhaps at a later stage I'll see if they are similar enough.
	
	// Resources will be a useful way to access things behind the scenes.
	//  A resource could be a File_System_Site where various things are published (though some can be witheld).
	
	
	
	
	
	// A website as a resource?
	//  And then resources have admin mechanisms too?
	//  Publishers - publish the data
	//   The server as a resource in some sense does work.
	//   But we really need it serving something soon, while being configuarable with the admin interface.
	// But the resource pool may be good enough for the server - there can be a root resource configured within that.
	//  Then there is a 'site' resource.
	
	
	
	
	// But a website as a resource... and the resource or concept of it fits in in many places.
	//  Making a resource pool available through an admin interface will be helpful... but then it may be best to make the 
	//  resource pool a resource itself.
	// I feel as though at present a few subsystems are missing or not fully developed.
	//  This may require a few layers of abstraction...
	//   For example a file system could be exposed as a resource, with files and directories as sub-resources.
	//    Those files could have sub-resources within them, such as a PSD file's layers.
	// And a website could reference a file system resource.
	
	// Will be good to be able to administer the file system as a resource.
	//  So, the server resource pool could start up a file system resource too.
	// May want a website resource.
	
	// For the moment, I think the file system resource is the one that makes the most sense to work on.
	//  Don't want this resource to be all that complicated, it's going to deal with the files but not do complex things like fs2.
	
	// Though, there will be Resource Processors, that will extract or transform one resource into another.
	
	// Quite a few things need to be done for this to fit together well.
	//  Resources can just be there, they can be published too.
	
	// Resources also describe a lot of things. They may really exist as metadata in the programming framework and files
	//  elsewhere.
	
	// May want to define a few remote servers as resources? Scan these remote resources and determine sub-resources?
	//  A server could certainly count as a resource, except it is more the service we are interested in consuming.
	
	// Eg could say the UN website is a resource. Then could scan that resource for subresources.
	//  A file on the local disk is a resource.
	//  Other copies of the file remotely would both need to work as different resources and as the same resource.
	
	// Resources will be very varied, and will be used to refer to almost anything on or off the internet.
	//  A server's admin could be a resource.
	// And a Resource Adapter would adapt from one resource type to another.
	
	// Really want this in a GUI.
	//  Something nice with a treeview.
	
	// Resource, and sub-resources.
	//  If the Resource_Pool is a Resource, then it could be accessed using general resource interfaces.
	//   Resource_Pool could be a resource that effectively counts as multiple resources.
	//   Having the server as a resource may make sense with showing the admin interface.
	
	// Perhaps Resource_Admin?
	//  With that being a resource?
	
	// Or there is a Control to administer a resource...
	//  Or the resource has various RESTful methods / properties attached.
	//  A Resource Adapter could be or act as a resource. So we could give it a resource id,
	//   and some parameters, and it then acts as another resource.
	//  Eg we could have something that adapts a website to extract certain data from it - and present that in a different way.
	// Need the resource system to be reasonably flexible, but in some ways follow a simple API.
	
	
	
			// no... takes the abstract resource.
			//  An abstract resource MAY have a network location.
			//  An abstract resource given to the Resource_Connector MUST have a network_location or some other means of identifying it.
			//  Abstract-Resource MAY have location field.
			//   The location field MAY be a Network_Location.
			//    Other Location classes may be made at a later date, such as a Distributed_Service_Location, where the servers / objects are named somehow else, and
			//     their network locations are obtained by consulting an index.
			
			// have the requirements system.
			//  Maybe adapt get/set/data types so it can work with internal (not nec private) data.
			//   Not made available to the things that use it using its main published API.
			
			
			//this.set('abstract_resource', spec.abstract_resource);
			
			
			
			// the resource may have a name.
			
			//if (is_defined(spec))
			

			
			// startup_type
			
			// _requirements, requires() and check_requirements could be moved to Data_Object.
			//  Resources check the requirements when it starts. Starting, stopping and being published with a Publisher are the features most significant to resource.
			//   Requirements has got more general applications, such as for authenticating HTML forms on the client.
			
			
			// will have capabilities for adding and removing requirements.
			//  require postgres_server
			//  require server_info
			
			// various things will be put into place so that the server can check that the requirements are met before starting.
			//  would also be able to be used in a chain, so starting one thing can get other things to start in a sequence.
			//   this may be best coordinated using a resource pool.
			
			//if (is_defined(spec.network_location)) {
			//	this.set('network_location', spec.network_location);
			//}
			
			
			// in general will hold information about the location of the resources
			//  (network location)
			// authentication info
			// further resource access information (such as the name of the database)
			//  (maybe the name of the database and the name of the table)
			//  (maybe the query that needs to be done on the web page to get the information required)
			// I've got to get this working as a node.js server.
			// The extra configurability won't really make it harder to use... boilerplate samples will help with that.
			//  Want to make a powerful CMS (MetaBench CMS).
			//   Likely to be a bit more than just what is in JSGUI, but won't be so hard to put it together.
			//    Not sure about releasing that as open source, but could make decent money from providing enterprise support.
			
			// Various other web applications, probably to do with websites and IT.
			//  iOS app creation software on the iOS platform.
			
			// Quite a few possibilities, but need the programming framework in JavaScript.
			
			
			//  May work towards making a search engine of some description
			//   (quite probably dealing with data).
			
			// Resources make the program more complex
			// The program is dealing with things that are a little complex.
			
			// I think this should be a bit like an OS in that plenty of things are set up and available, but only various things are used.
			// More complex system then just the code running as JavaScript, there will be some interpretation of instructions and code done by the JavaScript system.
			
			// Want to be able to wrap Data_Object items as resources.
			// An adapter for exposing a Data_Object
			// Will need to adapt a variety of things to work as resources.
			
			// May make some particular resources and resource types.
			//  An index of where to find / look for local resources
			
			// These various things will be started up and have different phases.
			// will have 'starting' and 'running' states, 'stopped'? not running? 
			//  Starting the local resources to start with...
			//  Just a bit of information, and the means to connect to other resources.
			
			// I think a fair bit of new programming will be put in this 'resource' wrapper.
			//  Resources will have / be able to have information about who is able to use them, their availability.
			//  Some resources will be published, with a resource publisher.
			
			// Describing publishing will help the application have control over what the system does.
			//  An abstraction that will help make data and resources available through the application, and also through network APIs such as REST.
			
			// These abstractions may seem a little pointless to begin with - but they will provide the structure where lots of functionality can be added to,
			//  and used within the application.
			
			// Making remote / external resources available as local seems like one of the main goals.
			// There is also the capability of making local resources available over a network / remotely.
			
			// Resource connector
			// Resource publisher
			// The resource itself.
			
			// Resource API...
			//  Says what data is available
			//  (Obtains the data)
			//  Provides the data.
			
			// Resources starting up in the right sequence.
			//  Could make a plan / come up with conditions.
			//   Once a,b,c have started, start d
			//   Should have a fairly effiecient way of providing these events.
			
			// So, when one or more resources get started from the resource pool, the resource pool puts together a 'Resource Start Plan'
			//  Each resource has its unique name within the system.
			
			// The resources should not take long to start up.
			//  There may be some that take some time, these may have to provision network resources.
			//  A flexible system of provisioning would be nice, so a service could be started very quickly
			
			// A resource could be set to automatically start?
			//  Or is that starting pecific to that pool?
			//  I think telling them to automatically start within the program is appropriate.
			
			// Coming up with the starting plan will take a bit of work though.
			//  These are instructions to start resources in response to particular other resources having been started properly.
			//  May have it raise events when perticular sets of resources have been started.
			
			// Quick lookup of resource status by name.
			//  Will be checking for a few things at once in response to one of the resources starting.
			//   When doing the event for a few resources having started:
			//    When any of them starts, check to see if they are all 'on'. If they are, raise the event.
			//    This is functionality in the Resource_Pool.
			
			// Also need to be able to check the dependencies to see if all of the resources that are needed as prerequesites for some resources are available.
			
			
			
			
		// Asyncronize get and set...
		//  When it applies to a normal Data_Object.
		
		// A Resource is essentially a Data_Object that can operate in asyncronous mode.
		
		
		
		
		// DataObject already has 'get' and 'set'.
		//  Perhaps those will be overridden?
		
		
		
	    
		// some resources will need to stay connected.
		//  others won't.
		//   however, would need to keep checking them at a certain frequency.
		//    a schedule could be created for this.
		
		// connect / test connection.
	
	
	
		
	// And Resources directly interface with the web?
	//  Or they go through a Publisher class?

	// A File_System resource, then it's published with a Restful API?

	// A Restful_Http_File_System resource - would save on having to do all the abstraction, and would 
	//  (possibly) count as a resource.
	
	// A website resource?
	// Just not (site), the site is the root web resource.

	// A default Web_Resource...
	//  A blank site?
	//   But we want the web resource to be administerable as well.
	//   Website_Resource may make sense.

	// Perhaps being able to administer the resources makes sense.
	//  But to do that maybe we'll use an Admin_Web_Interface resource.


